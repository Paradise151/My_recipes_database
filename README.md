## **Часть 1. Информационная модель базы данных кулинарных рецептов.**  
База данных моих скромных рецептов. Зачем это?
1) Прикольно. Готовка бывает веселой и прекрасной, особенно если готовит Гордон Рамзи.  
2) Чтобы в чём-то разобраться, надо: a) своими словами мочь рассказать, b) обдумать основные проблемы – суть дела, c) разобраться, почему основные моменты вообще стали таковыми (т.е. понять причины их появления — "эволюционная ретроспектива") и d) используя имеющиеся знания, закрепить их, реализуя нечто тебе приятное и их включающее.  
Значит, чтобы получше в SQL стать, надо настругать таблички и позаполнять их.  

Таковыми табличками, под управлением базы данных, будут составляющие процесса приготовления.
На важный самостоятельный объект будет создаваться своя таблица.

Что это за объекты?  
Рецепт включает: ингредиенты, время готовки, последовательность шагов (что с ингредиентами делают) и т.д..  
Значит, **ингредиенты** помещаются в отдельную таблицу (1).  
Последовательность шагов — отдельная таблица, именуемая **шагами готовки** (2).  
Теперь, что пишется в рецепте — например, взяли мясо и отбили его или порезали.  И что же получается, надо в каждую строку подобное писать? А если ошибки будут или решишь по-другому назвать; тогда возникнет хаос! Как потом из этого общую информацию извлекать?! Для систематизации декомпозируем шаги готовки и выделим из них группы с общими свойствами, которые и станут нашими новыми объектами.  
Получаем такие объекты, как **духовка** (3), **плита** (4), **мультиварка** (5), **микроволновка** (6), **холодная готовка** (7) — сюда относятся всякие отбивания, промывания, нарезания, в общем, что выполняется человеком.  
Затем надо как-то систематизировать сами ингредиенты, у них же тоже общие свойства есть. Таким образом, появляется таблица **тип ингредиентов** (8), в которой содержатся такие вещи, как специи, мясо, овощи,  рыба и т.д..  
Названия самих блюд будут исходить из **таблицы рецепты** (9). Можно было бы объединить *таблицу рецептов* (9) и *таблицу шагов готовки* (2), но рецепт содержит автора и некоторый комментарий, может ещё  содержать год создания; также одно блюдо может иметь разные рецепты, а значит, одного названия блюда недостаточно для корректной связки шагов по приготволению блюда с его рецептом; поэтому надо использовать именно индекс рецепта!   
Мы хотим, чтобы в *таблице шаги готовки* (2) был один унифицированный столбик, отвечающий за физическое взаимодействие с ингредиентом; поэтому создадим **таблицу шагов** (10), в которой будут содержаться все  возможные действия с ингредиентами (эти действия будут получаться по индексам из таблиц *холодная готовка*, *плита*, *духовка* и т.д.). Безусловно, можно было бы не создавать *таблицу шагов* (10) и объединить  её с *шагами готовки* (2), но тогда в последней (2) было бы на 4 столбца больше и снизился бы её "кулинарный" (схематичный) вид.  
Помимо прочего, у каждого рецепта есть и свой скромный автор, поэтому создадим **таблицу авторов** (11). Также весьма усместным была бы **таблица тип блюда** (12), например, гарнир, первое блюдо...

## **Часть 2. Краткое описание таблиц и их связей.**  
Таблицы **духовка** (3), **мультиварка** (5), **плита** (4), **микроволновка** (6), **холодная готовка** (7) одинаковы по строению: содержат первичный ключ и название режима (name_mode). Таблица **шаги** (10) ссылается на первичные ключи вышеописанных таблиц средств готовки (4 внешних ключа) и содержит первичный ключ (step_id). Таблица **авторов** (11), помимо первичного ключа, включает имя автора (name_author). Таблица **тип блюда** (12), содержащая первичный ключ, включает название типа блюда (name_dish_type). Таблица **рецептов** (9) ссылается на первичные ключи таблицы авторов и типов блюда, также она содержит следующие атрибуты: название рецепта (name_recipe), число порций (number_of_servings), первичный ключ (recipe_id) и комментарий к рецепту (description). Таблица **тип ингредиентов** (8) имеет первичный ключ и название типа (name_ingredient_type). Таблица **ингредиенты** (1) ссылается на первичный ключ таблицы тип ингредиентов и включает название ингредиента (name_ingredient). И, напоследок, таблица **шагов готовки** (2) ссылается на первичные ключи трёх таблиц: - ингредиенты, шаги готовки и рецепты. И, помимо первичного ключа, содержит следующие атрибуты: число частей (pieces, может быть как штуками, так и долями, например, 1.5 порции воды на 1 порцию риса), вес в кг (weight_kg), время готовки в минутах (cooking_time_minute), температура (temperature_celcius), уровень духовки снизу (oven_level_from_bottom) и давление (специально для мультиварки).  
  
Таким образом, получаем следующую архитектуру базы данных (ER-диаграмму):
![ER диаграмма базы данных рецептов](https://github.com/Paradise151/My_recipes_database/blob/main/ER%20diagram%20of%20Recipe%20DB.png)
## **Часть 3. Шаблоны.**  
Заметим, что в процессе заполнения таблицы и написания к ней запросов некоторые части кода повторяются. Назовём их шаблонами и выпишем. Жирным обозначим моменты в шаблонах, на которые стоит обратить внимание.
В readme.md ограничимся описанием главного шаблона вставки строки рецепта.  
...    
8. Шаблон №8 “Заполнение таблицы recipe_steps”

Для заполнения таблицы с точки зрения недопущения ошибок при присваивании атрибуту некоторого значения отлично подходит обновление с указанием какому столбцу какое значение присваивается.  
Но дабы избежать лишних запросов на обновление, будем сразу все атрибуты в таблицу recipe_steps вставлять.  

INSERT INTO recipe_steps(  
    recipe_id,  
    ingredient_id,  
    pieces,  
    weight_kg,  
    step_id,  
    cooking_time_minute,  
    temperature_celcius,    
    oven_level_from_bottom,  
    pressure)  
VALUES  
(  
(SELECT recipe_id FROM recipe WHERE name_recipe = 'Картофель бейби в духовке'),  -- recipe_id  
(SELECT ingredient_id FROM ingredient WHERE name_ingredient  = 'Картофель бейби'),  -- ingredient_id  
NULL,  -- pieces  
NULL,  -- weight_kg  
(SELECT step_id    
 FROM step   
	 LEFT JOIN  cold_preparation USING(cold_preparation_id)  
	 LEFT JOIN  multicooker USING(multicooker_id)  
	 LEFT JOIN  microwave USING(microwave_id)  
	 LEFT JOIN oven USING(oven_id)  
	 LEFT JOIN cooktop USING(cooktop_id)  
 WHERE cold_preparation.name_mode = 'Поместить в пакет для запекания'),   -- step_id  
4,  -- cooking_time_minute  
NULL,  -- temperature_celcius  
NULL,  -- oven_level_from_bottom  
NULL  -- pressure  
);  

Хорошо, но на одну строку очень много муторного кода, который приходится копировать и заполнять десятки раз. Лучше оформить это в виде функции (процедуры), получающие некоторые параметры, которые в прошлом приходилось перекопировать или искать место и вписывать. Вот что получилось:  
CALL InsertRecipeStep(
    'Котлеты из индейки (с хлебом) в духовке',  -- recipe_name
    'Белый хлеб',                               -- ingredient_name
    1,                                       -- pieces
    0.150,                                       -- weight_kg
    'Положить/Налить в миску',                          -- step_mode
    1,                                          -- cooking_time
    NULL,                                       -- temperature
    NULL,                                       -- oven_level
    NULL,                                       -- pressure
    'cold_preparation'                                      -- appliance_type
);  
Круто, очень эстетично и даёт выйгрыш в 17 строк!




